<!-- image -->

## www.ti.com

- Device Type coding
- IOs isolation control

## 8.1.5.1.5 Clocks Interface

This interface gathers all clock inputs and outputs managed by PRCM modules.

## 8.1.5.1.6 Resets Interface

This interface gathers all resets inputs and outputs managed by PRCM module.

## 8.1.5.1.7 Modules Power Management Control Interface

Modules or subsystems in the device are split over 2 categories:

- Initiator: an initiator is a module able to generate traffic on the device interconnects (typically: processors, MMU, EDMA).
- Target: a target is a module that cannot generate traffic on the device interconnects, but that can generate interrupts or DMA request to the system (typically: peripherals). PRCM handles a power management handshake protocol with each module or sub-system. This protocol allows performing proper clock and power transition taking into account each module activity or state.

## 8.1.5.1.8 Initiator Modules Interface

PRCM module handle all initiator modules power management interfaces: MStandby signal MWait signal

## 8.1.5.1.9 Targets Modules Interface

PRCM module handle all target modules power management interfaces: SIdleReq signal SIdleAck signal FCLKEN signal

Note:

USB Support for SWakeUp

## 8.1.6 Clock Generation and Management

PRCM provides a centralized control for the generation, distribution and gating of most clocks in the device. PRCM gathers external clocks and internally generated clocks for distribution to the other modules in the device. PRCM manages the system clock generation

## 8.1.6.1 Terminology

The PRCM produces 2 types of clock:

Interface clocks: these clocks primarily provide clocking for the system interconnect modules and the portions of device's functional modules which interface to the system interconnect modules. In most cases, the interface clock supplies the functional module's system interconnect interface and registers. For some modules, interface clock is also used as functional clock. In this document, interface clocks are represented by blue lines.

Functional clock: this clock supplies the functional part of a module or a sub-system. In some cases, a module or a subsystem may require several functional clocks: 1 or several main functional clock(s), 1 or several optional clock(s). A module needs its main clock(s) to be operational. Optional clocks are used for specific features and can be shutdown without stopping the module

## 8.1.6.2 Clock Structure

To generate high-frequency clocks, the device supports multiple on-chip DPLLs controlled directly by the PRCM module. They are of two types of PLLs, referred to ADPLLS and ADPLLLJ throughout this document.

The ADPLLS module is used for the Core, Display, ARM Subsystem and DDR PLLs

The ADPLLLJ module is used for the peripheral functional clocks

Figure 8-8. ADPLLS

<!-- image -->

The ADPLLS has three input clocks:

- CLKINP: Reference input clock
- CLKINPULOW: Low frequency input clock for bypass mode only.
- CLKINPHIF: High Frequency Input Clock for post-divider M3

The ADPLLS has four output clocks:

- CLKOUTHIF: High Frequency Output Clock from Post divider M3
- CLKOUTX2: Secondary 2x Output
- CLKOUT: Primary output clock
- CLKDCOLDO: Oscillator (DCO) output clock with no bypass

<!-- image -->

The device has two reference clocks which are generated by on-chip oscillators or externally. These are for the main clock tree and RTC block, respectively.

In the case of an external oscillator, a clock can directly be connected to XTALIN pin and the oscillator will be put in bypass mode. The 32-Khz crystal oscillator is controlled and configurable by RTC IP. This device also contains an on-chip RC oscillator. This oscillator is not configurable and is always on.

The main oscillator on the device (see Chapter 26, Initialization , for possible frequencies) produces the master high frequency clock CLK\_M\_OSC.

## 8.1.6.3 ADPLLS

The ADPLLS is a high resolution frequency synthesizer PLL with built in level shifters which allows the generation of PLL locked frequencies up to 2 GHz. ADPLLS has a predivide feature which allows user to divide, for instance, a 24- or 26-MHz reference clock to 1-MHz and then multiply up to 2-GHz maximum.

All PLLs will come-up in bypass mode at reset. SW needs to program all the PLL settings appropriately and then wait for PLL to be locked. For more details, see the configuration procedure for each PLL.

The following PLLs are:

- MPU PLL
- Core PLL
- Display PLL
- DDR PLL

<!-- image -->

## www.ti.com

The DPLL has two internal clocks:

- REFCLK (Internal reference clock): This is generated by dividing the input clock CLKINP by the programmed value N+1. The entire loop of the PLL runs on the REFCLK. Here, REFCLK = CLKINP/(N+1).
- BCLK: Bus clock which is used for programming the various settings using registers

The ADPLLS lock frequency is defined as follows: fDPLL = CLKDCOLDO

## 8.1.6.3.1 Clock Functions

Table 8-17. Output Clocks in Locked Condition

| Pin Name     | Frequency                          | Comments         |
|--------------|------------------------------------|------------------|
| REGM4XEN='0' | REGM4XEN='0'                       | REGM4XEN='0'     |
| CLKOUT       | [M / (N+1)] * CLKINP * [1/M2]      |                  |
| CLKOUTX2     | 2 * [M / (N+1)] * CLKINP * [1/M2]  |                  |
| CLKDCOLDO    | 2 * [M / (N+1)] * CLKINP           |                  |
| CLKOUTHIF    | CLKINPHIF / M3                     | CLKINPHIFSEL='1' |
| CLKOUTHIF    | 2 * [M / (N+1)] * CLKINP * [1/M3]  | CLKINPHIFSEL='0' |
| REGM4XEN='1' | REGM4XEN='1'                       | REGM4XEN='1'     |
| CLKOUT       | [4M / (N+1)] * CLKINP * [1/M2]     |                  |
| CLKOUTX2     | 2 * [4M / (N+1)] * CLKINP * [1/M2] |                  |
| CLKDCOLDO    | 2 * [4M / (N+1)] * CLKINP          |                  |
| CLKOUTHIF    | CLKINPHIF / M3                     | CLKINPHIFSEL='1' |
| CLKOUTHIF    | 2 * [4M / (N+1)] * CLKINP * [1/M3] | CLKINPHIFSEL='0' |

## Table 8-18. Output Clocks Before Lock and During Relock Modes

| Pin Name   | Frequency       | Comments      |
|------------|-----------------|---------------|
| CLKOUT     | CLKINP / (N2+1) | ULOWCLKEN='0' |
| CLKOUT     | CLKINPULOW      | ULOWCLKEN='1' |
| CLKOUTX2   | CLKINP / (N2+1) | ULOWCLKEN='0' |
| CLKOUTX2   | CLKINPULOW      | ULOWCLKEN='1' |
| CLKDCOLDO  | Low             |               |
| CLKOUTHIF  | CLKINPHIF/M3    | ULOWCLKEN='1' |
| CLKOUTHIF  | Low             | ULOWCLKEN='0' |

Note: Since M3 divider is running on the internal LDO domain, in the case when CLKINPHIFSEL='1', CLKOUTHIF could be active only when internal LDO is ON. Hence, whenever LDOPWDN goes low to high to powerdown LDO (happens when TINITZ activated / when entering slow relock bypass mode), output CLKOUTHIF will glitch and stop. To avoid this glitch, it is recommended to gate CLKOUTHIF using control CLKOUTHIFEN before asserting TINITZ / entering any slow relock bypass mode Frequency Range (MHz)

See the device-specific data manual for details on operating performance points (OPPs) supported by your device.

## 8.1.6.4 ADPLLLJ (Low Jitter DPLL)

The ADPLLLJ is a low jitter PLL with a 2-GHz maximum output. ADPLLLJ has a predivide feature which allows user to divide, for instance, a 24-MHz or 26-MHz reference clock to 1 MHz and then multiply up to 2 GHz maximum.

All PLLs will come-up in bypass mode at reset. SW needs to program all the PLL settings appropriately and then wait for PLL to be locked. For more details, see the configuration procedure for each PLL.

Figure 8-9. Basic Structure of the ADPLLLJ

<!-- image -->

The Peripheral PLL belongs to type ADPLLLJ:

The DPLL has two input clocks:

- CLKINP: Reference input clock
- CLKINPULOW: Bypass input clock.

The DPLL has two internal clocks:

- REFCLK (Internal reference clock): This is generated by dividing the input clock CLKINP by the programmed value N+1. The entire loop of the PLL runs on the REFCLK. Here, REFCLK = CLKINP/(N+1).
- CLKDCOLDO (Internal Oscillator clock.):This is the raw clock directly out of the digitally controlled oscillator (DCO) before the post-divider. The PLL output clock is synthesized by an internal oscillator which is phase locked to the refclk. There are two oscillators built within ADPLLLJ. The oscillators are user selectable based on the synthesized output clock frequency requirement. In locked condition, CLKDCOLDO = CLKINP *[M/(N+1)].

The ADPLLLJ lock frequency is defined as follows: fDPLL = CLKDCOLDO

The DPLL has three external output clocks:

- CLKOUTLDO: Primary output clock in VDDLDOOUT domain. Bypass option not available on this output.
- CLKOUTLDO = (M / (N+1))*CLKINP*(1/M2)
- CLKOUT: Primary output clock on digital core domain
- CLKOUT = (M / (N+1))*CLKINP*(1/M2)
- CLKDCOLDO: Oscillator (DCO) output clock before post-division in VDDLDOOUT domain. Bypass option is not available on this output. CLKDCOLDO = (M / (N+1))*CLKINP.

<!-- image -->

<!-- image -->

www.ti.com

All clock outputs of the DPLL can be gated. The Control module provides the DPLL with a clock gating control signal to enable or disable the clock, and the DPLL provides the PRCM module with a clock activity status signal to let the PRCM module hardware know when the clock is effectively running or effectively gated. Output clock gating control for various clockouts: CLKOUTEN/CLKOUTLDOEN/CLKDCOLDOEN.

## 8.1.6.4.1 Clock Functions

Table 8-19. Output Clocks in Locked Condition

| Pin Name   | Frequency                    |
|------------|------------------------------|
| CLKOUT     | [M /(N+1)] * CLKINP * [1/M2] |
| CLKOUTLDO  | [M /(N+1)] * CLKINP * [1/M2] |
| CLKDCOLDO  | [M /(N+1)] * CLKINP          |

Table 8-20. Output Clocks Before Lock and During Relock Modes

| Pin Name   | Frequency     | Comments      |
|------------|---------------|---------------|
| CLKOUT     | CLKINP/(N2+1) | ULOWCLKEN='0' |
| CLKOUT     | CLKINPLOW     | ULOWCLKEN='1' |
| CLKDCOLDO  | LOW           |               |
| CLKOUTLDO  | LOW           |               |

## 8.1.6.5 M2 Change On-the-Fly

The divider M2 is designed to change on the fly and provide a glitch-free frequency switch from the old to new frequencies. It can be changed while the PLL is in a locked condition without having to switch to bypass mode. A status toggle bit will give an indication if the new divisor was accepted. The divider M2 can also be changed in bypass mode, and the new divisor value will be reflected on output after the PLL relocks. For more details, see the PLL configuration procedures for each PLL.

## 8.1.6.6 Spread Spectrum Clocking (SSC)

NOTE:

Spread spectrum clock is only supported for the DISP/LCD and MPU PLLs on this device. Spread spectrum clocking is not supported for DDR, PER, and CORE PLLs. When enabling SSC on MPU PLL, ensure the maximum MPU frequency remains below the maximum rated frequency for the chosen OPP (see the device-specific Data Manual for more details).

The module supports spread spectrum clocking (SSC) on its output clocks. SSC is used to spread the spectral peaking of the clock to reduce any electromagnetic interference (EMI) that may be caused due to the clock's fundamental or any of its harmonics. When SSC is enabled the clock's spectrum is spread by the amount of frequency spread, and the attenuation is given by the ratio of the frequency spread ( Δ f) and the modulation frequency (f m), i.e., [{10*log10(Df/f m)}-10] dB.

## 8.1.6.6.1 Definition

The aim of SSC is to add a variation in the frequency of an original clock, which spreads the generated interferences over a larger band of frequency.

In theory, SSC means that the clock signal is varied around the desired frequency. For example, for a 1GHz clock, the frequency may be 999.5 MHz at one moment and 1.0005 GHz at another. When SSC is enabled the clock spectrum is spread by the amount of frequency spread. Doing this constantly causes the power of the tone to be spread out more over a broader band of tight frequencies (centered at the desired tone). To realize this constant variation on the original signal, a modulation with an additional signal (called spreading waveform) is realized.

Creating an SSC by spreading the initial clock frequency is done by defining the following parameters:

<!-- image -->

- The spreading frequency (deviation), which is the ratio of the range of spreading frequency over the original clock frequency
- The modulation rate (f m), which is used to determine the clock-frequency spreading-cycling rate and is the time during which the generated clock frequency varies through Δ f and returns to the original frequency
- The modulation waveform, which describes the variation curve in terms of time

The spectral power reduction in the DPLL clocks is dependent on the modulation index (K), which is a ratio of spreading frequency calculated from the frequency deviation ( Δ f) and the modulation rate (f m) .

## 8.1.6.6.2 Effect on the Clock Signal

Figure 8-10 is an example of the effect of a triangular spreading on a clock signal.

## Figure 8-10. Effect of the SSC in Frequency

<!-- image -->

scm-038

Figure 8-10 shows not only the power reduction of the main peak, but also the flatter aspect of the modulated signal. The minimum level of the second signal is higher than the minimum level of the first signal. This effect is normal and is due to the noise added for the modulation.

NOTE:

The spreading technique scatters the energy of the peaks on the other frequencies, which reduces the power of the peaks but increases the global noise of the signal.

Figure 8-11 shows the effect of triangular spreading on a clock signal in the time domain.

<!-- image -->

www.ti.com

Figure 8-11. Effect of the SSC in the Time Domain

<!-- image -->

## 8.1.6.6.3 Estimation of the EMI Reduction Level

Figure 8-12 shows the effect of spreading on a clock and its harmonics.

Figure 8-12. Peak Reduction Caused by Spreading

<!-- image -->

The electromagnetic interference reduction can be estimated with the following equation: Peak\_power\_reduction = 10 * log ((Deviation * f c ) / fm

With:

- Peak\_power\_reduction in dB
- Deviation in % of the initial clock frequency (f c ), equals Δ f / f c
- f c is the original clock frequency, in MHz
- fm is the spreading frequency, in MHz

According to equation (1), it is also possible to compute the deviation, and then Δ f, for a required peak power reduction:

Deviation = (fm / f c ) * 10 (Peak\_power\_reduction / 10)

Example:

For f c =400 MHz, deviation =1% peak from f c ( Δ f = 4MHz) and fm=400kHz; the estimated peak power reduction is 10dB.

## 8.1.6.6.4 Bandwidth Calculation (Carson Bandwidth Rule)

The Carson bandwidth rule defines the approximate bandwidth requirements of communications system components for a carrier signal that is frequency-modulated by a continuous or broad spectrum of frequencies rather than a single frequency.

The Carson bandwidth rule is expressed by the relation CBR = 2 * ( Δ f + f m), where CBR is the bandwidth requirement, Δ f is the peak frequency deviation, and fm is the highest frequency in the modulating signal.

For example, an FM signal with a 5-kHz peak deviation and a maximum audio frequency of 3 kHz, would require an approximate bandwidth 2*(5 3) = 16 kHz.

Theoretically, any FM signal has an infinite number of sidebands and hence an infinite bandwidth, but in practice all significant sideband energy (98% or more) is concentrated within the bandwidth defined by the Carson bandwidth rule.

## 8.1.6.6.5 SSC Generation Control in the Device

SSC is performed by changing the feedback divider (M) in a triangular pattern. Implying, the frequency of the output clock would vary in a triangular pattern. The frequency of this pattern would be modulation frequency (f m). The peak ( Δ M) or the amplitude of the triangular pattern as a percent of M would be equal to the percent of the output frequency spread ( Δ f); that is, Δ M/M= Δ f / f c . Next mark with Finp the frequency of the clock signal at the input of the DPLL. Because it is divided to N+1 before entering the phase detector, so the internal reference frequency is Fref = Finp / (N + 1).

Assume the central frequency f c to be equal to the DPLL output frequency Fout, or f c = Fout = (Finp / (N + 1)) * (M / M2). Since this is in band modulation for the DPLL, the modulation frequency is required to be within the DPLL's loop bandwidth (lowest BW of Fref / 70). A higher modulation frequency would result in lesser spreading in the output clock.

SSC can be enabled/disabled using bit CM\_CLKMODE\_DPLL\_xxx.DPLL\_SSC\_EN (where xxx can be any one of the following DPLLs: MPU, DDR, DISP, CORE, PER). An acknowledge signal CM\_CLKMODE\_DPLL\_xxx.DPLL SSC\_ACK notifies the exact start and end of SSC. When SSC\_EN is de-asserted, SSC is disabled only after completion of one full cycle of the triangular pattern given by the modulation frequency. This is done in order to maintain the average frequency.

Modulation frequency (f m) can be programmed as a ratio of Fref / 4; that is, the value that needs to be programmed ModFreqDivider = Fref / (4*f m). The ModFreqDivider is split into Mantissa and 2^Exponent (ModFreqDivider = ModFreqDividerMantissa * 2^ModFreqDividerExponent). The mantissa is controlled by 7-bit signal ModFreqDividerMantissa through

CM\_SSC\_MODFREQDIV\_DPLL\_xxx.MODFREQDEV\_MANTISSA bit field. The exponent is controlled by 3bit signal ModFreqDividerExponent through the

CM\_SSC\_MODFREQDIV\_DPLL\_xxx.MODFREQDEV\_EXPONENT bit field.

NOTE:

Although the same value of ModFreqDivider can be obtained by different combinations of mantissa and exponent values, it is recommended to get the target ModFreqDivider by programming maximum mantissa and a minimum exponent.

<!-- image -->

www.ti.com

<!-- image -->

www.ti.com

To define the Frequency spread ( Δ f), Δ M must be controlled as explained previously. To define Δ M, the step size of M for each Fref during the triangular pattern must be programmed; that is,

Δ M = (2^ModFreqDividerExponent) * ModFreqDividerMantissa * DeltaMStep IF ModFreqDividerExponent ≤ 3 Δ M = 8 * ModFreqDividerMantissa * DeltaMStep IF ModFreqDividerExponent &gt; 3

DeltaMStep is split into integer part and fractional part. Integer part is controlled by 2-bit signal DeltaMStepInteger through the CM\_SSC\_DELTAMSTEP\_DPLL\_xxx.DELTAMSTEP\_INTEGER bit field. Fractional part is controlled by 18-bit signal DeltaMStepFraction through the CM\_SSC\_DELTAMSTEP\_DPLL\_xxx.DELTAMSTEP\_FRACTION bit field.

The frequency spread achieved has an overshoot of 20 percent or an inaccuracy of +20 percent. If the CM\_CLKMODE\_DPLL.DPLL\_SSC\_DOWNSPREADis set to 1, the frequency spread on lower side is twice the programmed value. The frequency spread on higher side is 0 (except for the overshoot as described previously).

There is restriction of range of M values. The restriction is MΔ M should be ≥ 20. Also, M+ Δ M should be ≤ 2045. In case the downspread feature is enabled, M-2* Δ M should be ≥ 20 and M ≤ 2045.

## 8.1.6.6.6 SSC Generation

The configuration of the spreading feature is not mandatory when programming the DPLL. This feature is usually enabled when the DPLL clocks generate harmonics that can potentially interfere with the GSM carrier frequencies.

Let's take the SSC featured Display ADPLL and try to set the output frequency to F out = f c = 11 MHz. Software most likely sets the DPLL higher to clock the DSS module at a higher functional clock, and then sets the DISPC\_DIVISOR to achieve an 11 MHz pixel clock. But in this example, the PLL is set to output 11 MHz. The frequency of the input clock source for Display ADPLL is F inp = 25 MHz.

1. The desired output frequency can be achieved with the following ratio of the divider coefficients: (M / M2) * 1 / (N + 1) = F out / Finp = 11 / 25. The dividers used in the Display ADPLL can be set within the following ranges: N = 0..127; M = 0..2047; M2 = 1;2. The desired output frequency is achieved through the following choice of possible divider values: M = 22; N = 4; and M2 = 10. In that case the reference clock F ref = Finp / (N + 1) = 25 / (4 + 1) = 5 MHz.
2. The feedback divider value M = 22 is chosen to satisfy the restriction from Section 8.1.6.6. If, for example, the deviation Δ M / M = Δ f f c = 0.05 (5%) is chosen, we have M + Δ M &lt; 2045 and at the same time M + Δ M &gt; 20
3. Once the clock generation control registers are configured, it is possible to configure the spreading on the clock signal.
2. Calculate the ratio between central(output) frequency and modulation frequency on the base of the desired peak power reduction (PPR) and chosen relative deviation Δ f / Fout , where Δ f / Fout = fm / f c * 10 ^ (PPR / 10). To achieve PPR = 10dB with SSC deviation ( Δ f / f c ) chosen to be equal to 5 percent, f m = Δ f / 10 (PPR/10) = 55 kHz. To check whether the modulation frequency has the appropriate value, check whether it is within the DPLL loop bandwidth or if fm &lt; Fref / 70 = 5 / 70 = 71.4 KHz, which is true.
3. Calculate the contents of the MODFREQDEV\_MANTISSA and MODFREQDEV\_EXPONENT bit fields on the base of ModFreqDivider value: ModFreqDivider = F ref / (4 * f m) = 5 / (4 * 0.055) = 22.73. The resulting value needs to be put in the form MODFREQDEV\_MANTISSA * 2 MODFREQDEV\_EXPONENT . Thus, we can approximate 23 = 23 * 20. The approximation will just slightly affect the PPR.
6. This means we should write MODFREQDEV\_EXPONENT = 0x0 and MODFREQDEV\_MANTISSA = 0x17.
4. The DeltaMStep parameter is calculated according to the formula: DeltaMStep = Δ M / ModFreqDivider. Since Δ M = M * ( Δ f / f c ), DeltaMStep = M * ( Δ f / f c ) / ModFreqDivider. Thus in this example, DeltaMStep = 22 * 0.05 / 23 = 0.047826.
8. In this case, write 0x0 in DELTAMSTEP\_INTEGER (bits 19:18). To express the fractional part 0.05 as a binary, calculate: 0.047826 * 2^18 = 12537.3, then round to 12537, convert the integer part to binary and write it into the field: DELTAMSTEP\_FRACTIONAL (bits 17:0) = 0x30F9.
5. The spreading must be enabled using the SSC\_EN bit.

NOTE:

<!-- image -->

It is necessary to configure the spreading on a clock carefully to avoid adding noise on frequencies that are used by another module. For example, adding spreading on a clock to reduce noise on GSM frequencies can "move" the generated noise to the frequency of the memory controller and degrade its performance.

The state of the modulation feature can be monitored with the DPLL\_SSC\_ACK bit of the corresponding register.

## 8.1.6.7 Core PLL Description

The Core PLL provides the source for a majority of the device infrastructure and peripheral clocks. The Core PLL comprises an ADPLLS with HSDIVIDER and additional dividers and muxes located in the PRCM as shown in Figure 8-13.

## Figure 8-13. Core PLL

ALT\_CLKs are to be used for internal test purpose and should not be used in functional mode.

<!-- image -->

<!-- image -->

www.ti.com

## Table 8-21. PLL and Clock Frequences

| Mux Select   | Register BitSection 9.2.4.4     |
|--------------|---------------------------------|
| A            | PRCM.CLKSEL_GFX_FCLK[1]         |
| B            | PRCM.CLKSEL_GFX_FCLK[0]         |
| C            | PRCM.CLKSEL_PRU-ICSS_OCP_CLK[0] |
| D            | PRCM.CM_CPTS_RFT_CLKSEL[0]      |
| E            | TEST.CDR (via P1500)            |

Table 8-22 gives the typical PLL and clock frequencies. The HSDIVIDER is used to generate three divided clocks M4, M5 &amp; M6. M4 &amp; M5 are nominally 200 &amp; 250 MHz, respectively.

Table 8-22. Core PLL Typical Frequencies (MHz)

| CLOCK                                                                    | Source         | Power-On-Reset / HSDIVIDER Bypass   | Power-On-Reset / HSDIVIDER Bypass   | OPP100    | OPP100     | OPP50 (1)(2)   | OPP50 (1)(2)   |
|--------------------------------------------------------------------------|----------------|-------------------------------------|-------------------------------------|-----------|------------|----------------|----------------|
| CLOCK                                                                    | Source         | DIV                                 | Freq                                | DIV Value | Freq (MHz) | DIV Value      | Freq (MHz)     |
| CLKDCOLDO (PLL Lock frequency)                                           | APLLS          | -                                   | -                                   | -         | 2000       | -              | 100            |
| CORE_CLKOUTM4                                                            | HSDIVIDER- M4  | -                                   | Mstr Xtal                           | 10        | 200        | 1              | 100            |
| L3F_CLK, L4F_CLK, PRU-ICSS IEP CLK, DebugSS clka, SGX.MEMCLK, SGX.SYSCLK | CORE_CLKO UTM4 | -                                   | Mstr Xtal                           | -         | 200        | -              | 100            |
| L4_PER, L4_WKUP                                                          | CORE_CLKO UTM4 | 2                                   | Mstr Xtal / 2                       | 2         | 100        | 2              | 50             |
| SGX CORECLK                                                              | CORE_CLKO      | 1                                   | Mstr Xtal                           | 1         | 200        | 1              | 100            |
|                                                                          | UTM4           |                                     |                                     | 2         | 100        | 2              | 50             |
| CORE_CLKOUTM5                                                            | HSDIVIDER- M5  | -                                   | Mstr Xtal                           | 8         | 250        | 1              | 100            |
| MHZ_250_CLK (Gigabit RGMII)                                              | CORE_CLKO UTM5 | -                                   | NA                                  | -         | 250        | -              | NA             |
| MHZ_125_CLK (Ethernet Switch Bus Clk)                                    | CORE_CLKO UTM5 | 2                                   | Mstr Xtal / 2                       | 2         | 125        | 2              | 50             |
| MHZ_50_CLK (100 mbps RGMII or 10/100 RMII)                               | CORE_CLKO UTM5 | 5                                   | Mstr Xtal / 5                       | 5         | 50         | 2              | 50             |
| MHZ_5_CLK (10 mbps RGMII)                                                | MHZ_50_CLK     | 10                                  | Mstr Xtal / 50                      | 10        | 5          | 10             | 5              |
| CORE_CLKOUTM6                                                            | HSDIVIDER M6   | -                                   | Mstr Xtal                           | 4         | 500        | 1              | 100            |

(1) Not all interfaces and peripheral modules are available in OPP50. For more information, see the device specific datasheet.

(2) For limitations using OPP50, see AM335x ARM Cortex-A8 Microprocessors (MPUs) Silicon Errata (literature number SPRZ360).

The ADPLLS module supports two different bypass modes via their internal MNBypass mode and their external Low Power Idle bypass mode. The PLLs are in the MNBypass mode after power-on reset and can be configured by software to enter Low Power Idle bypass mode for power-down.

When the Core PLL is configured in bypass mode, the HSDIVIDER enters bypass mode and the CLKINBYPASS input is driven on the M4, M5, and M6 outputs. CLKINBYPASS defaults to the master oscillator input (typically 24 MHz).

Table 8-23. Bus Interface Clocks

| L3F_CLK     | SGX530 (MEMCLK & SYSCLK), LCDC, MPU Subsystem, GEMAC Switch (Ethernet), DAP, PRU-ICSS, EMIF, TPTC, TPCC, OCMC RAM, DEBUGSS, AES, SHA                                                                                                                                                                            |
|-------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| L3S_CLK     | USB, TSC, GPMC, MMCHS2, McASP0, McASP1                                                                                                                                                                                                                                                                          |
| L4_PER_CLK  | DCAN0, DCAN1, DES DMTIMER2, DMTIMER3, DMTIMER4, DMTIMER5, DMTIMER6, DMTIMER7 eCAP/eQEP/ePWM0, eCAP/eQEP/ePWM1, eCAP/eQEP/ePWM2, eFuse ELM, GPIO1, GPIO2, GPIO3 I2C1, I2C2, IEEE1500, LCD, Mailbox0 McASP0, McASP1 MMCHS0, MMCHS1, OCP Watchpoint, PKARNG SPI0, SPI1, Spinlock UART1, UART2, UART3, UART4, UART5 |
| L4_WKUP_CLK | ADC_TSC, Clock Manager, Control Module DMTIMER0, DMTIMER1_1MS, GPIO0 I2C0, M3UMEM, M3DMEM, SmartReflex0, SmartReflex1 UART0, WDT0, WDT1                                                                                                                                                                         |

## 8.1.6.7.1 Core PLL Configuration

1. Switch PLL to bypass mode by setting CM\_CLKMODE\_DPLL\_CORE.DPLL\_EN to 0x4.
2. Wait for CM\_IDLEST\_DPLL\_CORE.ST\_MN\_BYPASS = 1 to ensure PLL is in bypass (CM\_IDLEST\_DPLL\_CORE.ST\_DPLL\_CLK should also change to 0 to denote the PLL is unlocked).
3. Configure Multiply and Divide values by setting CM\_CLKSEL\_DPLL\_CORE.DPLL\_MULT and DPLL\_DIV to the desired values.
4. Configure M4, M5 and M6 dividers by setting HSDIVIDER\_CLKOUT1\_DIV bits in CM\_DIV\_M4\_DPLL\_CORE,CM\_DIV\_M5\_DPLL\_CORE, and CM\_DIV\_M6\_DPLL\_CORE to the desired values.
5. Switch over to lock mode by setting CM\_CLKMODE\_DPLL\_CORE.DPLL\_EN to 0x7.
6. Wait for CM\_IDLEST\_DPLL\_CORE.ST\_DPLL\_CLK = 1 to ensure PLL is locked (CM\_IDLEST\_DPLL\_CORE.ST\_MN\_BYPASS should also change to 0 to denote the PLL is out of bypass mode).

Note: M4, M5, and M6 dividers can also be changed on-the-fly so that there is no need to put the PLL in bypass and back to lock mode. After changing CM\_DIV\_Mx\_DPLL\_CORE.DPLL\_CLKOUT\_DIV, check CM\_DIV\_Mx\_DPLL\_CORE.DPLL\_HSDIVIDER\_CLKOUT1\_DIVCHACK for a toggle (a change from 0 to 1 or 1 to 0) to see if the change was acknowledged by the PLL.

## 8.1.6.8 Peripheral PLL Description

The Per PLL provides the source for peripheral functional clocks. The Per PLL comprises an ADPLLLJ and additional dividers and muxes located in the PRCM as shown

<!-- image -->

<!-- image -->

www.ti.com

Figure 8-14. Peripheral PLL Structure

<!-- image -->

*Reset default zero

ALT\_CLKs are to be used for internal test purpose and should not be used in functional mode.

The PLL is locked at 960 MHz. The PLL output is divided by the M2 divider to generate a 192-MHz CLKOUT. This clock is gated in the PRCM to form the PRU-ICSS UART clock. There is a /2 divider to create 96 MHz for MMC\_CLK. The clock is also divided within the PRCM by a fixed /4 divider to create a 48-MHz clock for the SPI, UART and I2C modules. The 48-MHz clock is further divided by a fixed /2 divider and a fixed /732.4219 divider to create an accurate 32.768-KHz clock for Timer and debounce use.

Table 8-24. Per PLL Typical Frequencies (MHz)

| Clock                      | Source                                                                                                 | Power-On-Reset / PLL Bypass   | Power-On-Reset / PLL Bypass   | OPP100    | OPP100     | OPP50 (1)(2)   | OPP50 (1)(2)   |
|----------------------------|--------------------------------------------------------------------------------------------------------|-------------------------------|-------------------------------|-----------|------------|----------------|----------------|
| Clock                      | Source                                                                                                 | DIV Value                     | Freq                          | DIV Value | Freq (MHz) | DIV Value      | Freq (MHz)     |
| PLL Lock frequency         | PLL                                                                                                    | -                             | -                             | -         | 960        | -              | 960            |
| USB_PHY_CLK                | CLKDCOLDO                                                                                              | -                             | Held Low                      | -         | 960        | -              | 960            |
| PER_CLKOUTM2               | CLKOUT of ADPLLLJ CLKOUT uses PLL's M2 Divider when PLL is locked and PLL's N2 divider when PLL Bypass | N2 is 0 on power-on-reset     | Mstr Xtal/ (N2+1)             | 5         | 192        | 10             | 96             |
| MMC_CLK                    | PER_CLKOUTM2                                                                                           | 2                             | Mstr Xtal/ ((N2+1)*2)         | 2         | 96         | 2              | 48             |
| SPI_CLK, UART_CLK, I2C_CLK | PER_CLKOUTM2                                                                                           | 4                             | Mstr Xtal/ ((N2+1)*4)         | 4         | 48         | 4              | 24             |
| CLK_24                     | CLK_48                                                                                                 | 2                             | CLK_48 /2                     | 2         | 24         | 2              | 12             |
| CLK_32KHZ                  | CLK_24 (output of CLK_48/2)                                                                            | 732.4219                      | CLK_24 / <CLK32_DIV>          | 732.4219  | 0.032768   | 366.2109       | 0.032768       |

(1) For limitations using OPP50, see AM335x ARM Cortex-A8 Microprocessors (MPUs) Silicon Errata (literature number SPRZ360).

(2) Not all interfaces and peripheral modules are available in OPP50. For more information, see AM335x ARM Cortex-A8 Microprocessors (MPUs) Silicon Errata (literature number SPRZ360).

<!-- image -->

The ADPLLLJ module supports two different bypass modes via their internal MNBypass mode and their external Low Power Idle bypass mode. The PLLs are in the MNBypass mode after power-on reset and can be configured by software to enter Low Power Idle bypass mode for power-down.

The PER PLL can use the Low Power Idle bypass mode. When the internal bypass mode is selected, the CLKOUT output is driven by CLKINP/(N2+1) where N2 is driven by the PRCM. CLKINP defaults to the master oscillator input (typically 24 MHz)

## 8.1.6.8.1 Configuring the Peripheral PLL

The following steps detail how to configure the peripheral PLL.

1. Switch PLL to bypass mode by setting CM\_CLKMODE\_DPLL\_PER.DPLL\_EN to 0x4.
2. Wait for CM\_IDLEST\_DPLL\_PER.ST\_MN\_BYPASS = 1 to ensure PLL is in bypass (CM\_IDLEST\_DPLL\_PER.ST\_DPLL\_CLK should also change to 0 to denote the PLL is unlocked).
3. Configure Multiply and Divide values by setting CM\_CLKSEL\_DPLL\_PER.DPLL\_MULT and DPLL\_DIV to the desired values.
4. Configure M2 divider by setting CM\_DIV\_M2\_DPLL\_PER.DPLL\_CLKOUT\_DIV to the desired value.
5. Switch over to lock mode by setting CM\_CLKMODE\_DPLL\_PER.DPLL\_EN to 0x7.
6. Wait for CM\_IDLEST\_DPLL\_PER.ST\_DPLL\_CLK = 1 to ensure PLL is locked (CM\_IDLEST\_DPLL\_PER.ST\_MN\_BYPASS should also change to 0 to denote the PLL is out of bypass mode).

Note: M2 divider can also be changed on-the-fly (ie., there is no need to put the PLL in bypass and back to lock mode). After changing CM\_DIV\_M2\_DPLL\_PER.DPLL\_CLKOUT\_DIV, check

CM\_DIV\_M2\_DPLL\_PER.DPLL\_CLKOUT\_DIVCHACK for a toggle (a change from 0 to 1 or 1 to 0) to see if the change was acknowledged by the PLL.

## 8.1.6.9 MPU PLL Description

The Cortex A8 MPU subsystem includes an internal ADPLLS for generating the required Cortex A8 MPU clocks. This PLL is driven by the master oscillator output with control provided by PRCM registers.

<!-- image -->

www.ti.com

Figure 8-15. MPU Subsystem PLL Structure

<!-- image -->

## For example:

For a frequency for MPU, say 600 MHz, the ADPLLS is configured (PLL locked at 1200 MHz and M2 Divider =1) so as to expect CLKOUT = 600 MHz .

The ULOWCLKEN input from a programmable PRCM register selects whether CLKINP or CLKINPULOW is the bypass clock source. This is a glitch free switch. When CLKINP is selected it is sourced through the ADPLLS 1/(N2+1) divider. The PRCM register defaults to 0 on power-up to select the CLKINP source.

The CLKINPULOW input may be sourced from the CORE\_CLKOUTM6 from the Core PLL, or PER\_CLKOUTM2 from the Per PLL. These PLL output clocks can be used as alternate clock sources in low power active use cases for the MPU Subsystem clock when the PLL is in bypass mode.

## 8.1.6.9.1 Configuring the MPU PLL

The following steps detail how to configure the MPU PLL.

1. Switch PLL to bypass mode by setting CM\_CLKMODE\_DPLL\_MPU.DPLL\_EN to 0x4.
2. Wait for CM\_IDLEST\_DPLL\_MPU.ST\_MN\_BYPASS = 1 to ensure PLL is in bypass (CM\_IDLEST\_DPLL\_MPU.ST\_DPLL\_CLK should also change to 0 to denote the PLL is unlocked).
3. Configure Multiply and Divide values by setting CM\_CLKSEL\_DPLL\_MPU.DPLL\_MULT and DPLL\_DIV to the desired values.
4. Configure M2 divider by setting CM\_DIV\_M2\_DPLL\_MPU.DPLL\_CLKOUT\_DIV to the desired value.
5. Switch over to lock mode by setting CM\_CLKMODE\_DPLL\_MPU.DPLL\_EN to 0x7.
6. Wait for CM\_IDLEST\_DPLL\_MPU.ST\_DPLL\_CLK = 1 to ensure PLL is locked (CM\_IDLEST\_DPLL\_MPU.ST\_MN\_BYPASS should also change to 0 to denote the PLL is out of bypass mode).

Note: M2 divider can also be changed on-the-fly (ie., there is no need to put the PLL in bypass and back to lock mode). After changing CM\_DIV\_M2\_DPLL\_MPU.DPLL\_CLKOUT\_DIV, check CM\_DIV\_M2\_DPLL\_MPU.DPLL\_CLKOUT\_DIVCHACK for a toggle (a change from 0 to 1 or 1 to 0) to see if the change was acknowledged by the PLL.

## 8.1.6.10 Display PLL Description

The Display PLL provides the pixel clock required for the LCD display and is independent from the other peripheral and infrastructure clocks. The PLL is clocked from the Master Oscillator. The ADPLLS M2 divider determines the output clock frequency which is clock gated by the PRCM as shown in Figure 8-16.

Figure 8-16. Display PLL Structure

<!-- image -->

For example: say frequency for pixel clock 100 MHz, the ADPLLS is configured (PLL locked at 200 MHz and M2 Divider =1) so as to expect CLKOUT = 100 MHz.

The ULOWCLKEN input from a programmable PRCM register selects whether CLKINP or CLKINPULOW is the bypass clock source. This is a glitch free switch. When CLKINP is selected it is sourced through the ADPLLS 1/(N2+1) divider. The PRCM register defaults to 0 on power-up to select the CLKINP source.

The CLKINPULOW input is sourced from the CORE\_CLKOUTM6 from the Core PLL or PER\_CLKOUTM2 from the Per PLL. This PLL output clock can be used as an alternate clock source in low power active use cases for the pixel clock when the Display PLL is in bypass mode.

## 8.1.6.10.1 Configuring the Display PLL

The following steps detail how to configure the display PLL.

1. Switch PLL to bypass mode by setting CM\_CLKMODE\_DPLL\_DISP.DPLL\_EN to 0x4.
2. Wait for CM\_IDLEST\_DPLL\_DISP.ST\_MN\_BYPASS = 1 to ensure PLL is in bypass (CM\_IDLEST\_DPLL\_DISP.ST\_DPLL\_CLK should also change to 0 to denote the PLL is unlocked).
3. Configure Multiply and Divide values by setting CM\_CLKSEL\_DPLL\_DISP.DPLL\_MULT and DPLL\_DIV to the desired values.
4. Configure M2 divider by setting CM\_DIV\_M2\_DPLL\_DISP.DPLL\_CLKOUT\_DIV to the desired value.
5. Switch over to lock mode by setting CM\_CLKMODE\_DPLL\_DISP.DPLL\_EN to 0x7.
6. Wait for CM\_IDLEST\_DPLL\_DISP.ST\_DPLL\_CLK = 1 to ensure PLL is locked (CM\_IDLEST\_DPLL\_DISP.ST\_MN\_BYPASS should also change to 0 to denote the PLL is out of bypass mode).

<!-- image -->

<!-- image -->

www.ti.com

Note: M2 divider can also be changed on-the-fly (ie., there is no need to put the PLL in bypass and back to lock mode). After changing CM\_DIV\_M2\_DPLL\_DISP.DPLL\_CLKOUT\_DIV, check CM\_DIV\_M2\_DPLL\_DISP.DPLL\_CLKOUT\_DIVCHACK for a toggle (a change from 0 to 1 or 1 to 0) to see if the change was acknowledged by the PLL.

## 8.1.6.11 DDR PLL Description

The DDR PLL provides the clocks required by the DDR macros and the EMIF and is independent from the other peripheral and infrastructure clocks. The PLL is clocked from the Master Oscillator. The ADPLLS M2 divider determines the output clock frequency which is connected directly to the DDR Macros. The clock is also routed through the PRCM where a fixed /2 divider is used to create the M\_CLK used by the EMIF as shown in Figure 8-17.

Figure 8-17. DDR PLL Structure

<!-- image -->

For OPP information, see the device-specific data manual.

Example frequency for DDR clock, say 266 MHz, the ADPLLS is configured (PLL locked at 532 MHz and M2 Divider =1) so as to expect CLKOUT = 266 MHz.

The ULOWCLKEN input from a programmable PRCM register selects whether CLKINP or CLKINPULOW is the bypass clock source. This is a glitch free switch. When CLKINP is selected it is sourced through the ADPLLS 1/(N2+1) divider. The PRCM register defaults to 0 on power-up to select the CLKINP source.

The CLKINPULOW input may be sourced from the CORE\_CLKOUTM6 from the Core PLL, or PER\_CLKOUTM2 from the Per PLL. These PLL output clocks can be used as alternate clock sources in low power active use cases for the DDR clocks when PLL is in bypass mode

## 8.1.6.11.1 Configuring the DDR PLL

The following steps detail how to configure the DDR PLL.

1. Switch PLL to bypass mode by setting CM\_CLKMODE\_DPLL\_DDR.DPLL\_EN to 0x4.
2. Wait for CM\_IDLEST\_DPLL\_DDR.ST\_MN\_BYPASS = 1 to ensure PLL is in bypass (CM\_IDLEST\_DPLL\_DDR.ST\_DPLL\_CLK should also change to 0 to denote the PLL is unlocked).
3. Configure Multiply and Divide values by setting CM\_CLKSEL\_DPLL\_DDR.DPLL\_MULT and DPLL\_DIV to the desired values.
4. Configure M2 divider by setting CM\_DIV\_M2\_DPLL\_DDR.DPLL\_CLKOUT\_DIV to the desired value.
5. Switch over to lock mode by setting CM\_CLKMODE\_DPLL\_DDR.DPLL\_EN to 0x7.
6. Wait for CM\_IDLEST\_DPLL\_DDR.ST\_DPLL\_CLK = 1 to ensure PLL is locked (CM\_IDLEST\_DPLL\_DDR.ST\_MN\_BYPASS should also change to 0 to denote the PLL is out of bypass mode).

<!-- image -->

Note: M2 divider can also be changed on-the-fly (i.e., there is no need to put the PLL in bypass and back to lock mode). After changing CM\_DIV\_M2\_DPLL\_DDR.DPLL\_CLKOUT\_DIV, check CM\_DIV\_M2\_DPLL\_DDR.DPLL\_CLKOUT\_DIVCHACK for a toggle (a change from 0 to 1 or 1 to 0) to see if the change was acknowledged by the PLL.

## 8.1.6.12 CLKOUT Signals

The CLKOUT1 and CLKOUT2 signals go device pads and should mainly be used as debug testpoints. Using these signals for time-critical external circuits is discouraged because of unpredictable jitter performance. For more information, see the device datasheet, AM335x Sitara Processors (literature number SPRS717). CLKOUT1 is created from the master oscillator. CLKOUT2 can be sourced from the 32-KHz crystal oscillator or any of the PLL (except MPU PLL) outputs. The selected output can be further modified by a programmable divider to create the desired output frequency.

Figure 8-18. CLKOUT Signals

<!-- image -->

## 8.1.6.13 Timer Clock Structure

The CLK\_32KHZ clock is an accurate 32.768-kHz clock derived from the PER PLL and can also be selected for the WDT1. The DMTIMER0 can only be clocked from the internal RC oscillator (CLK\_RC32K). The clock options are shown in Figure 8-19.

Figure 8-19. Watchdog Timer Clock Selection

<!-- image -->

<!-- image -->

www.ti.com

Figure 8-20. Watchdog and Secure Timer Clock Selection (For Secure Devices only)

<!-- image -->

All mux selections are in PRCM unless explicitly shown otherwise in the diagrams.

The clock selections for the other device Timer modules are shown in Figure 8-21. CLK\_32KHZ, the master oscillator, and the external pin (TCLKIN) are optional clocks available for timers which may be selected based on end use application.

DMTIMER1 is implemented using the DMTimer\_1ms module which is capable of generating an accurate 1ms tick using a 32.768 KHz clock. During low power modes, the Master Oscillator is disabled. CLK\_32KHZ also would not be available in this scenario since it is sourced from the Master Osc based PER PLL. Hence, in low power modes DMTIMER1 in the WKUP domain can use the 32K RC oscillator for generating the OS (operating system) 1ms tick generation and timer based wakeup. Since most applications expect an accurate 1ms OS tick which the inaccurate 32K RC (16-60 KHz) oscillator cannot provide, a separate 32768 Hz oscillator (32K Osc) is provided as another option.

Figure 8-21. Timer Clock Selection

<!-- image -->

All mux selections are in PRCM unless explicitly shown otherwise in the diagrams.

The RTC, Debounce and VTP clock options are shown in Figure 8-22. In low power modes, the debounce for GPIO0 in WKUP domain can use the accurate 32768 Hz crystal oscillator or the inaccurate (16 KHz to 60 KHz) 32K RC oscillator when the Master Osc is powered down.

The 32K Osc requires an external 32768-Hz crystal.

All mux selections are in PRCM unless explicitly shown otherwise in the diagrams.

<!-- image -->