## 20.2.3 Functional Description

The general-purpose timer is an upward counter. It supports three functional modes:

- Timer mode
- Capture mode
- Compare mode

By default, after core reset, the capture and compare modes are disabled.

## 20.2.3.1 Timer Mode Functionality

The timer is an upward counter that can be started and stopped at any time through the Timer Control Register (TCLR ST bit). The Timer Counter Register (TCRR) can be loaded when stopped or on the fly (while counting). TCRR can be loaded directly by a TCRR Write access with the new timer value. TCRR can also be loaded with the value held in the Timer Load Register (TLDR) by a trigger register (TTGR) Write access. The TCRR loading is done regardless of the value written to the TTGR register. The timer counter register TCRR value can be read when stopped or captured on the fly by a TCRR Read access. The timer is stopped and the counter value set to '0' when the module's reset is asserted. The timer is maintained in stop after reset is released. When the timer is stopped, TCRR is frozen. The timer can be restarted from the frozen value unless TCRR has been reloaded with a new value.

In the one shot mode (TCLR AR bit ='0'), the counter is stopped after counting overflow (counter value remains at zero).

When the auto-reload mode is enabled (TCLR AR bit ='1'), the TCRR is reloaded with the TLDR value after a counting overflow.

It is not recommended to put the overflow value (0xFFFFFFFF) in TLDR because it can lead to undesired results.

An interrupt can be issued on overflow if the overflow interrupt enable bit is set in the timer Interrupt Enable Register (TIER OVF\_IT\_ENA bit ='1'). A dedicated output pin (PORTIMERPWM) is programmed through TCLR (TRG and PT bits) to generate one positive pulse (prescaler duration) or to invert the current value (toggle mode) when an overflow occurs.

Figure 20-28. TCRR Timing Value

<!-- image -->

## 20.2.3.1.1 1 ms Tick Generation

To minimize the error between a true 1ms tick and the tick generated by the 32768 Hz timer, the sequencing of the sub-1ms periods and the over-1ms periods must be shuffled.

An additional block (1ms block) is used to correct this error.

In this implementation, the increment sequencing is automatically managed by the timer to minimize the error. The value of the Timer Positive Increment register (TPIR) and Timer Negative Increment register (TNIR) only need to be defined by the user. An auto adaptation mechanism is used to simplify the programming model.

<!-- image -->

<!-- image -->

www.ti.com

Figure 20-29. 1ms Module Block Diagram

<!-- image -->

The TPIR, TNIR, TCVR and adders Add1-3 are used to define whether the next value loaded in the TCRR will be the value of the TLDR (sub-period value) or the value of TLDR - 1 (over-period value).

The following table shows the value loaded in TCRR according to the sign of the result of Add1, Add2 and Add3. MSB = '0' means a positive value, MSB = '1' means a negative value.

Table 20-30. Value Loaded in TCRR to Generate 1ms Tick

|   Add1 MSB |   Add2 MSB |   Add3 MSB | TCRR     |
|------------|------------|------------|----------|
|          0 |          0 |          0 | TLDR     |
|          0 |          0 |          1 | TLDR     |
|          0 |          1 |          0 | TLDR     |
|          0 |          1 |          1 | TLDR - 1 |
|          1 |          0 |          0 | N.A.     |
|          1 |          0 |          1 | N.A.     |
|          1 |          1 |          0 | TLDR - 1 |
|          1 |          1 |          1 | TLDR - 1 |

The values of TPIR and TNIR registers are calculated with formula:

Positive Increment Value = ( ( INTEGER[ Fclk * Ttick ] + 1 ) * 1e6 ) - ( Fclk * Ttick * 1e6 )

Negative Increment Value = ( INTEGER[ Fclk * Ttick ] * 1e6 ) - ( Fclk * Ttick * 1e6 )

where:

Fclk - clock frequency (KHz)

Ttick - tick period (ms)

The Timer Overflow Counter Register (TOCR) and the Timer Overflow Wrapping Register (TOWR) are used for interrupt filtering. When the timer overflows, it increments the 24 bit TOCR register. When the 24bit TOCR register value matches the value in the 24 bit TOWR register and timer overflow is asserted, the TOCR is reset and an interrupt is generated to TISR.

With the Conversion block in reset state (Positive Increment register, Negative Increment register and Counter Value register are all zeroed), the programming model and the behavior of the DMtimer\_dmc1ms remain unchanged.

For 1 ms tick with a 32768-Hz clock:

TPIR = 232000

TNIR = -768000

TLDR = 0xFFFFFFE0

NOTE:

Any value of the tick period can be generated with the appropriate values of the TPIR, TNIR and TLDR registers.

By default, the TPIR, TNIR, TCVR, TOCR, TOWR registers and the associated logic are in reset mode (all 0s) and have no action on the programming model of the DMtimer\_dmc1ms.

## 20.2.3.2 Capture Mode Functionality

The timer value in TCRR can be captured and saved in TCAR1 or TCAR2 function of the mode selected in TCLR through the field CAPT\_MODE when a transition is detected on the module input pin (PIEVENTCAPT). The edge detection circuitry monitors transitions on the input pin (PIEVENTCAPT).

Rising transition, falling transition or both can be selected in TCLR (TCM bit) to trigger the timer counter capture. The module sets the TISR ( TCAR\_IT\_FLAG bit) when an active transition is detected and at the same time the counter value TCRR is stored in one of the timer capture registers TCAR1 or TCAR2 as follows:

- If TCLR's CAPT\_MODE field is '0' then, on the first enabled capture event, the value of the counter register is saved in TCAR1 register and all the next events are ignored (no update on TCAR1 and no interrupt triggering) until the detection logic is reset or the interrupt status register is cleared on TCAR's position by writing a '1' to it.
- If TCLR's CAPT\_MODE field is '1' then, on the first enabled captured event, the counter value is saved in TCAR1 register and, on the second enabled capture event, the value of the counter register is saved in TCAR2 register. If capture interrupt is enabled, the interrupt will be asserted on the second event capture. All the other events are ignored (no update on TCAR1/2 and no interrupt triggering) until the detection logic is reset or the interrupt status register is cleared on TCAR's position writing a '1' in it. This mechanism is useful for period calculation of a clock if that clock is connected to the PIEVENTCAPT input pin.

The edge detection logic is reset (a new capture is enabled) when the active capture interrupt is served. The TCAR\_IT\_FLAG bit of TISR (previously '1') is cleared by writing a "1" to it or when the edge detection mode bits TCLR (TCM bit) passed from the No Capture Mode detection to any other modes. The timer functional clock (input to prescaler) is used to sample the input pin (PIEVENTCAPT). Negative or positive input pulses can be detected when the pulse time exceeds the functional clock period. An interrupt can be issued on transition detection if the capture interrupt enable bit is set in the Timer Interrupt Enable Register TIER (TCAR\_IT\_ENA bit).

See the following examples:

<!-- image -->

<!-- image -->

In the next wave, the TCM value is '01' and CAPT\_MODE is '0'- only rising edge of the PIEVENTCAPT will trigger a capture in TCAR and only TCAR1 will update.

## Figure 20-30. Capture Wave Example for CAPT\_MODE 0

<!-- image -->

In the following example, the TCM value is '01' and CAPT\_MODE is '1'- only rising edge of the PIEVENTCAPT will trigger a capture in TCAR1 on first enabled event and TCAR2 will update on the second enabled event.

Figure 20-31. Capture Wave Example for CAPT\_MODE 1

<!-- image -->

## 20.2.3.3 Compare Mode Functionality

When Compare Enable TCLR (CE bit) is set to '1', the timer value (TCRR) is permanently compared to the value held in timer match register (TMAR). TMAR value can be loaded at any time (timer counting or stop). When the TCRR and the TMAR values match, an interrupt can be issued if the TIER (MAT\_IT\_ENA bit) is set. The correct implementation is to write a compare value in TMAR register before setting TCLR (CE bit) to avoid any unwanted interrupts due to a reset value matching effect.

The dedicated output pin (PORTIMERPWM) can be programmed through TCLR (TRG and PT bits) to generate one positive pulse (TIMER clock duration) or to invert the current value (toggle mode) when an overflow and a match occur.

## 20.2.3.4 Prescaler Functionality

A prescaler counter can be used to divide the timer counter input clock frequency. The prescaler is enabled when TCLR bit 5 is set (PRE). The 2n division ratio value (PTV) can be configured in the TCLR register.

The prescaler counter is reset when the timer counter is stopped or reloaded on the fly.

Table 20-31. Prescaler/Timer Reload Values Versus Contexts

| Contexts                       | Prescaler Counter   | Timer Counter   |
|--------------------------------|---------------------|-----------------|
| Overflow (when Auto-reload on) | reset               | TLDR            |
| TCRR Write                     | reset               | TCRR            |
| TTGR Write                     | reset               | TLDR            |
| Stop                           | reset               | Frozen          |

## 20.2.3.5 Pulse-Width Modulation

The timer can be configured to provide a programmable pulse-width modulation (PORTIMERPWM) output. The PORTIMERPWM output pin can be configured to toggle on a specified event. TCLR (TRG bits) determines on which register value the PORTIMERPWM pin toggles. Either overflow or match can be used to toggle the PORTIMERPWM pin, when a compare condition occurs.

In case of overflow and match mode, the match event will be ignored from the moment the mode was setup until the first overflow event occurs

The TCLR (SCPWM bit) can be programmed to set or clear the PORTIMERPWM output signal while the counter is stopped or the triggering is off only. This allows fixing a deterministic state of the output pin when modulation is stopped. The modulation is synchronously stopped when TRG bit is cleared and an overflow has occurred.

In the following timing diagram, the internal overflow pulse is set each time (0xFFFF FFFFF - TLDR +1) value is reached, and the internal match pulse is set when the counter reaches TMAR register value. According to TCLR (TRG and PT bits) programming value, the timer provides pulse or PWM on the output pin (PORTIMERPWM).

The TLDR and TMAR registers must keep values smaller than the overflow value (0xFFFFFFFF) with at least 2 units. In case the PWM trigger events are both overflow and match, the difference between the values kept in TMAR register and the value in TLDR must be at least 2 units. When match event is used, the compare mode TCLR (CE) must be set.

On the following wave TCLR (SCPWM bit) is set to '0'.

Timers

<!-- image -->

<!-- image -->

www.ti.com

<!-- image -->

On the next wave TCLR (SCPWM bit) is set to '1'.

Figure 20-33. Timing Diagram of Pulse-Width Modulation, SCPWM Bit = 1

<!-- image -->

## 20.2.3.6 Timer Interrupt Control

The timer can issue an overflow interrupt, a timer match interrupt and a timer capture interrupt. Each internal interrupt source can be independently enabled/disabled in the Interrupt Enable Register (TIER). When the interrupt event has been issued, the associated interrupt status bit is set in the Timer Status Register (TISR). The pending interrupt event is reset when the set status bit is overwritten by a '1' value. Reading the Interrupt Status Register and writing the value back allows for a fast acknowledge interrupt process.

## 20.2.3.7 Sleep Mode Request and Acknowledge

Upon a Sleep mode request issued by the host processor (the Idle Request PIOCPMIDLEREQ signal is active), the timer module will enter Sleep mode according to the IdleMode field of the System configuration register (see TIOCP\_CFG).

If the IdleMode field sets No-Idle mode, the Timer does not enter Sleep mode and the Idle acknowledge signal (POROCPSIDLEACK) is never asserted.

If the IdleMode field sets Force-Idle mode, the timer enters Sleep mode independently of the internal module state and the Idle acknowledge signal (POROCPSIDLEACK) is unconditionally asserted.

If the IdleMode field sets Smart-Idle mode, the timer module evaluates its internal capability to have the interface/functional clock switched off. Depending on the ClockActivity field, setting the timer module evaluates the internal activity and asserts the Idle acknowledge signal (POROCPSIDLEACK), entering in Sleep mode, ready to issue a wake-up request.

The following table describes the Smart Idle behavior according to the clock activity setting:

Table 20-32. SmartIdle - Clock Activity Field Configuration

|   Clock Activity | Functional Clock   | OCP Clock   | Module Behavior                                                                                                                                                                                                                                                                                                          |
|------------------|--------------------|-------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|               11 | ON                 | ON          | The Idle acknowledge signal is asserted when there are no pending activities on the OCP clock domain, without evaluating the pending activities on the functional clock domain. (The module will enter in Sleep mode and if a pending interrupt event is finished during Idle mode the wake-up signal will be asserted). |
|               10 | ON                 | OFF         | The Idle acknowledge signal is asserted when there are no pending activities on the OCP clock domain, without evaluating the pending activities on the functional clock domain. (The module will enter in Sleep mode and if a pending interrupt event is finished during Idle mode the wake-up signal will be asserted). |
|               01 | OFF                | ON          | The Idle acknowledge signal is asserted when there are no pending activities on the functional and OCP clock domains (Improved latency in assertion of Idle acknowledge). The Wake-up capability of the module is disabled.                                                                                              |
|               00 | OFF                | OFF         | The Idle acknowledge signal is asserted when there are no pending activities on the functional and OCP clock domains (Improved latency in assertion of Idle acknowledge). The Wake-up capability of the module is disabled.                                                                                              |

<!-- image -->

<!-- image -->

This wake-up request is effectively sent only if the field ENAWAKEUP of TIOCP\_CFG enables the timer wake-up capability. When the system is awaken, the Idle Request signal goes inactive and the wake-up request signal is also de-asserted.

Figure 20-34. Wake-up Request Generation

<!-- image -->

## 20.2.3.7.1 Wake-up Line Release

When the host processor receives a wake-up request issued by the timer peripheral, the interface clock is re-activated: the host processor deactivates the PIOCPMIDLEREQ, the timer deactivates the POROCPSIDLEACK signal and then the host can read the corresponding bit in TISR to find out which interrupt source has triggered a wake-up request. After acknowledging the wake-up request, the processor resets the status bit and releases the interrupt line by writing a '1' in the corresponding bit of the TISR register.

## 20.2.3.8 Timer Counting Rate

The dmtimer's counter is composed of a prescaler stage and a timer counter.

The prescaler clock ratio can be managed by accessing the ratio definition field of the control register (PTV and PRE of TCLR).

The timer rate is defined by:

- The value of the prescaler fields (PRE and PTV of TCLR register)
- The value loaded into the Timer Load Register (TLDR).

Table 20-33. Prescaler Clock Ratios Value

|   PRE | PTV   |   Divisor (PS) |
|-------|-------|----------------|
|     0 | X     |              1 |
|     1 | 0     |              2 |
|     1 | 1     |              4 |
|     1 | 2     |              8 |
|     1 | 3     |             16 |
|     1 | 4     |             32 |